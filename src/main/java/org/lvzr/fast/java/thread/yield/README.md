
###[java]多线程yield 的小议
http://blog.sina.com.cn/s/blog_5c5bc9070100yty9.html
http://blog.csdn.net/orangleliu/article/details/38309403

Thread.yield()方法作用是：**暂停**当前正在执行的线程对象，并执行其他线程。
 
yield()应该做的是**让当前运行线程回到可运行状态**，以允许具有相同优先级的其他线程获得运行机会。因此，
使用yield()的目的是让相同优先级的线程之间能适当的**轮转执行**。但是，实际中无法保证yield()达到让步目的，
因为让步的线程还有可能被线程调度程序再次选中。
 
结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。


在多线程中有这么一个状态yield，很多人翻译成线程让步。顾名思义，就是说当一个线程使用了这个方法之后，他就把自己的cpu时间让掉，
让自己或者其他的线程运行。

就好像说这个线程轮到他上厕所了，然后他说“我要和大家来个竞赛'，然后所有的人在同一起跑线冲向厕所。。。。有可能是别人进去了，
也有可能他自己有抢到了。

我们还知道线程有个优先级的问题，那么手里有优先权的这些人就一定能抢到厕所的位置吗? 不一定的，他们只是概率上大些，也有可能没特权的抢到了。

这里有２块注释，１号注释和２号注释。
1 ,2号都注释的情况下：２个线程叫做高低，其实呢都是平民，这时候其实你看不出在i=30的时候有什么区别。

没有1,2注释的情况下：多次运行，你只会发现yt1这个进程抢cpu的技术比较高，每次都先完成。仔细观察i=30那条打印信息的地方
 

2种情况下高都是先执行到30，第1种情况高都执行到50了，低还没有到30；
第2种情况下高30执行，在高没结束的时候，低执行到30了。


理想情况是2：不管是“高”“低”，执行到30的时候，System.out.println("我是"+this.getName()); 应该是不执行的，另外一个线程继续执行，
在以后的某个时刻得到cpu才执行打印信息的命令。

特殊情况1： 因为“高”已经执行完了，所以剩下的时间都是“低”的cpu的时间了，“低”就慢慢的执行呗，i=30的时候"低“是让出了cpu，但是没人抢呀，
自己就继续执行了。 

那这种情景在什么样的需求下能用到呢，比如甲乙两个人一替一会工作， “甲”在某个特定的时间遇到危险，让“乙”这个的苦逼临时当替罪羊，
过阵子在继续做自己的工作。然后他们在一替一会的工作。。。。。
！！！但这只是说概率问题，没法从精确读上确保一定会这样发生，只是练习时候发现问题，提出来思考下。。。。。
相同优先级可能会出现这个种情况
 
 
 
